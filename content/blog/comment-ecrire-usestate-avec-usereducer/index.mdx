---
title: 'Comment √©crire useState avec useReducer'
date: '2021-03-12'
description: 'Impl√©menter useState avec useReducer'
tags:
  - React
  - Frontend
  - Hooks
creditsUserUrl: https://commons.wikimedia.org/wiki/File:React-icon.svg
creditsUser: Facebook
featuredImage: cover.png
growth: 'üå≥'
---

Aujourd'hui je vais te montrer un petit truc assez sympa que j'ai d√©couvert gr√¢ce √† un article de [Kent C. Dodds](https://kentcdodds.com/blog/how-to-implement-usestate-with-usereducer). Comme tu l'as remarqu√© dans le titre, il est possible d'√©crire notre propre `useState` gr√¢ce √† `useReducer`.

L'article ci-dessus est plut√¥t explicatif et tr√®s bien fait donc je t'invite vivement √† aller le lire apr√®s üòâ

## R√©sum√© (TLDR;)

‚¨á‚¨á‚¨á Pour les plus press√©s üòè et adeptes du `Ctrl-C / Ctrl-V` ‚¨á‚¨á‚¨á

```jsx
import { useReducer } from 'react'

const reducer = (state, action) =>
  typeof action === 'function' ? action(state) : action

const useState = initialValue => useReducer(reducer, initialValue)
export default useState
```

## useState

Pour rappel, `useState` permet de g√©rer l'√©tat d'un composant fonctionnel

```jsx
const TextField = () => {
  const [value, setValue] = React.useState('')
  return <input value={value} onChange={evt => setValue(evt.target.value)} />
}
```

Il prend un argument optionnel qui permet d'initialiser la valeur de l'√©tat et retourne un tableau contenant l'√©tat (`value`) et la fonction de mise-√†-jour de celui-ci (`setValue`)

> Tu peux nommer l'√©tat et la fonction de mise √† jour comme tu veux, par exemple `banane` et `setBanane`

La fonction de mise-√†-jour de l'√©tat prend √† son tour un argument qui deviendra la prochaine valeur de l'√©tat. A noter que cet argument peut prendre la forme d'une fonction (callback). Dans ce cas, le callback prend comme argument la valeur pr√©c√©dente de l'√©tat.

```jsx
const Counter = () => {
  const [count, setCount] = React.useState(0)
  const handleClick = () => {
    // le callback prend comme param√®tre la valeur pr√©c√©dente de `count`
    const cb = prevCount => prevCount + 1
    setCount(cb)
  }
  return <p onClick={handleClick}>{count}</p>
}
```

> Cette fa√ßon de mettre √† jour l'√©tat avec un callback est une bonne pratique lorsque la valeur suivante d√©pend de la pr√©c√©dente

Enfin, il est possible aussi d'initialiser la valeur de l'√©tat en mode lazy si l'initialisation prend beaucoup de temps. Je m'explique.

```jsx
const Component = () => {
  const initialStateValue = veryExpensiveInit()
  const [state, setState] = useState(initialStateValue)
  return // .....
}
```

`veryExpensiveInit` est une fonction qui prend √©norm√©ment de temps pour s'ex√©cuter. Cela a pour cons√©quence de ralentir le rendu du composant.

A chaque mis-√†-jour et re-rendu du composant, `initialStateValue` est re-calcul√© m√™me s'il n'est pas utilis√© par `useState` puisqu'on n'a besoin de la valeur initiale qu'au tout premier rendu.

Vient alors l'initialisation en mode _lazy_. Il consiste √† envoyer en param√®tre √† `useState` une fonction qui appelle `veryExpensiveInit`

React se charge ainsi d'appeler cette fonction uniquement si le composant est √† son tout premier rendu.

```jsx
const Component = () => {
  // `veryExpensiveInit` ne sera ex√©cut√©
  // que si le composant est affich√© pour la premi√®re fois
  const [state, setState] = useState(() => veryExpensiveInit())
  return // .....
}
```

En r√©sum√©, si nous voulons r√©-impl√©menter `useState` , les fonctionnalit√©s √† respecter sont

- initialisation optionnelle de l'√©tat
- mise-√†-jour de l'√©tat avec une nouvelle valeur
- mise-√†-jour de l'√©tat √† partir de la valeur pr√©c√©dente
- initialisation en mode _lazy_
