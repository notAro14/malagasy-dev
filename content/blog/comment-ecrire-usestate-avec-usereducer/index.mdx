---
title: 'Comment Ã©crire useState avec useReducer'
date: '2021-03-11'
description: 'ImplÃ©menter useState avec useReducer'
tags:
  - React
  - Frontend
  - Hooks
creditsUserUrl: https://commons.wikimedia.org/wiki/File:React-icon.svg
creditsUser: Facebook
featuredImage: cover.png
growth: 'ðŸŒ³'
---

Aujourd'hui je vais te montrer un petit truc assez sympa que j'ai dÃ©couvert grÃ¢ce Ã  un article de [Kent C. Dodds](https://kentcdodds.com/blog/how-to-implement-usestate-with-usereducer). Comme tu l'as remarquÃ© dans le titre, il est possible d'Ã©crire notre propre `useState` grÃ¢ce Ã  `useReducer`.

L'article ci-dessus est plutÃ´t explicatif et trÃ¨s bien fait donc je t'invite vivement Ã  aller le lire aprÃ¨s ðŸ˜‰

## RÃ©sumÃ© (TLDR;)

Pour les plus pressÃ©s ðŸ˜ et adeptes du `Ctrl-C / Ctrl-V`

```js
import { useReducer } from 'react'

const reducer = (state, newState) =>
  typeof newState === 'function' ? newState(state) : newState

const initializer = initialValue =>
  typeof initialValue === 'function' ? initialValue() : initialValue

const useState = initialValue => useReducer(reducer, initialValue, initializer)

export default useState
```

## useState - Rappel

Pour rappel, `useState` permet de gÃ©rer l'Ã©tat d'un composant fonctionnel

```jsx
const TextField = () => {
  const [value, setValue] = React.useState('')
  return <input value={value} onChange={evt => setValue(evt.target.value)} />
}
```

Il prend un argument optionnel qui permet d'initialiser la valeur de l'Ã©tat et retourne un tableau contenant l'Ã©tat (`value`) et la fonction de mise-Ã -jour de celui-ci (`setValue`)

> Tu peux nommer l'Ã©tat et la fonction de mise Ã  jour comme tu veux, par exemple `banane` et `setBanane`

La fonction de mise-Ã -jour de l'Ã©tat prend Ã  son tour un argument qui deviendra la prochaine valeur de l'Ã©tat. A noter que cet argument peut prendre la forme d'une fonction (callback). Dans ce cas, le callback prend comme argument la valeur prÃ©cÃ©dente de l'Ã©tat.

```jsx
const Counter = () => {
  const [count, setCount] = React.useState(0)
  const handleClick = () => {
    // le callback prend comme paramÃ¨tre la valeur prÃ©cÃ©dente de `count`
    const cb = prevCount => prevCount + 1
    setCount(cb)
  }
  return <p onClick={handleClick}>{count}</p>
}
```

> Cette faÃ§on de mettre Ã  jour l'Ã©tat avec un callback est une bonne pratique lorsque la valeur suivante dÃ©pend de la prÃ©cÃ©dente

Enfin, il est possible aussi d'initialiser la valeur de l'Ã©tat en mode lazy si l'initialisation prend beaucoup de temps. Je m'explique.

```js
const Component = () => {
  const initialStateValue = veryExpensiveInit()
  const [state, setState] = useState(initialStateValue)
  return // .....
}
```

`veryExpensiveInit` est une fonction qui prend Ã©normÃ©ment de temps Ã  exÃ©cuter. Cela a pour consÃ©quence de ralentir le rendu du composant.

A chaque mise-Ã -jour et re-rendu du composant, `initialStateValue` est re-calculÃ© mÃªme s'il n'est pas utilisÃ© par `useState` puisqu'on n'a besoin de la valeur initiale qu'au tout premier rendu.

Vient alors l'initialisation en mode _lazy_. Il consiste Ã  envoyer en paramÃ¨tre Ã  `useState` une fonction qui appelle `veryExpensiveInit`

React se charge ainsi d'appeler cette fonction uniquement si le composant est Ã  son tout premier rendu.

```js
const Component = () => {
  // `veryExpensiveInit` ne sera exÃ©cutÃ©
  // que si le composant est affichÃ© pour la premiÃ¨re fois
  const [state, setState] = useState(() => veryExpensiveInit())
  return // .....
}
```

En rÃ©sumÃ©, si nous voulons rÃ©-implÃ©menter `useState` , les fonctionnalitÃ©s Ã  respecter sont

- initialisation et mise-Ã -jour de l'Ã©tat avec une nouvelle valeur
- mise-Ã -jour de l'Ã©tat avec une fonction callback
- initialisation en mode "lazy"

## useReducer - Alternative Ã  useState

`useReducer` est un hook qui permet aussi de gÃ©rer l'Ã©tat d'un composant. Il est prÃ©fÃ©rable de l'utiliser si le composant requiert une logique plus complexe.

Il reÃ§oit deux arguments:

- une fonction `reducer` de la forme `(state, action) => newState`
- une valeur initiale de l'Ã©tat

Et retourne un tableau de 2 Ã©lÃ©ments:

- la valeur de l'Ã©tat
- la fonction de mise-Ã -jour de l'Ã©tat que l'on appelle conventionnellement `dispatch`

Remarque

> `action` est l'argument que l'on passe Ã  la fonction `dispatch` pour mettre Ã  jour l'Ã©tat

### Exemple avec un Compteur (oui encore un eniÃ¨me compteur ðŸ˜)

```jsx
import { useReducer } from 'react'

const reducer = (state, action) => {
  switch (action) {
    case 'INCREMENT':
      return state + 1
    case 'DECREMENT':
      return state - 1
    case 'RESET':
      return 0
    default:
      return state
  }
}

const Counter = () => {
  const [count, dispatch] = useReducer(reducer, 0)
  return (
    <main>
      <p>{count}</p>
      <button onClick={() => dispatch('INCREMENT')}>+</button>
      <button onClick={() => dispatch('DECREMENT')}>-</button>
      <button onClick={() => dispatch('RESET')}>Reset</button>
    </main>
  )
}
```

## ImplÃ©menter useState avec useReducer

### Initialisation et mise-Ã -jour de l'Ã©tat

Avec ce que l'on sait de `useReducer`, il n'y a Ã  priori pas beaucoup de difficultÃ©s Ã  implÃ©menter cette fonctionnalitÃ©.

```js
import {useReducer} from 'react'

// j'ai renommÃ© `action` en `newState`
// mais son nom n'a pas vraiment d'importance
// le plus important Ã  retenir est que cet argument
// est celui que l'on fait passer au `reducer` grÃ¢ce Ã  `dispatch`
const reducer = (state, newState) => return newState

const useState = (initialValue) => {
  // j'ai renommÃ© `dispatch` en `setState`
  const [state, setState] = useReducer(reducer, initialValue)
  return [state, setState]
}
```

En simplifiant, on a

```js
const reducer = (state, newState) => newState
const useState = initialValue => useReducer(reducer, initialValue)
```

### Mise-Ã -jour de l'Ã©tat avec un callback

Il faut maintenant que la fonction `dispatch` (ou `setState`) ait la capacitÃ© de savoir si on passe une valeur ou une fonction en paramÃ¨tre de celle-ci.

Pour cela, on teste tout simplement le type de `action` (ou `newState`)

- si c'est une fonction, on l'exÃ©cute en lui passant comme argument l'Ã©tat prÃ©cÃ©dent et on renvoie le rÃ©sultat
- si c'est une valeur on la renvoie directement

```diff
- const reducer = (state, newState) => newState
+ const reducer = (state, newState) => typeof newState === 'function' ? newState(state) : newState
```

```js
const reducer = (state, newState) =>
  typeof newState === 'function' ? newState(state) : newState
const useState = initialValue => useReducer(reducer, initialValue)
```

## Initialisation de l'Ã©tat en mode lazy ou "Lazy initialization"

La solution Ã  celle-ci est moins Ã©vidente mais la clÃ© Ã  ce problÃ¨me se trouve [ici](https://reactjs.org/docs/hooks-reference.html#lazy-initialization). Oui, `useReducer` peut recevoir un 3Ã¨me argument qui permet de faire une "lazy initalization".

```js
useReducer(reducerFunction, initialState, initializer)
```

Ce 3Ã¨me argument `initializer` est exÃ©cutÃ©e de la sorte

```js
initializer(initialState)
```

Elle a Ã©tÃ© prÃ©vue exactement pour les mÃªmes raisons que `useState`. C'est-Ã -dire permettre au dÃ©veloppeur d'exÃ©cuter une fonction d'initialisation, coÃ»teuse en ressources, uniquement au premier appel de `useReducer`

```js
// ce code
const initialValue = someProps
const initialState = veryExpensiveInit(initialValue)
const [state, dispatch] = useReducer(reducer, initialState)

// devient alors
const initialValue = someProps
const initializer = initialValueArg => veryExpensiveInit(initialValueArg)
const [state, dispatch] = useReducer(reducer, initialValue, initializer)
```

Dans notre cas, on veut savoir si l'argument reÃ§u par notre `useState` et transfÃ©rÃ© Ã  `React.useReducer` est une fonction ou une valeur. Pour cela on ajoute une fonction `initializer` et on fait cette vÃ©rification Ã  l'intÃ©rieur de celle-ci.

```js
const reducer = (state, newState) =>
  typeof newState === 'function' ? newState(state) : newState

const initializer = initialValue =>
  typeof initialValue === 'function' ? initialValue() : initialValue

const useState = initialValue => useReducer(reducer, initialValue, initializer)
```

## Conclusion

Le but maintenant n'est pas de refaire la mÃªme chose dans ton code et de remplacer tous tes `React.useState` par un `useState` custom (Ã§a ne sert Ã  rien)

Mon objectif Ã©tait d'expliquer simplement le fonctionnement de ces fonctions qui sont `useState` et `useReducer` pour te permettre (et me permettre aussi au passage ðŸ˜‰) d'avoir une comprÃ©hension plus fine de celles-ci.
